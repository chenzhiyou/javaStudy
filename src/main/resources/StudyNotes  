面向对象：
关注现实存在的事物的各方面的信息，从对象的角度出发，根据事务的特征进行程序设计
对象：用来描述客观事物的一个实体
类：具有相同属性和方法的一组对象的集合

面向对象设计原则：单一职责原则
构造方法：
1.构造方法与类同名且没有返回值
2.构造方法的语句格式
3.构造方法只能在对象实例化的时候调用
4.当没有指定构造方法时，系统会自动添加无参的构造方法
5.当有指定构造方法，无论是有参、无参的构造方法，都不会自动添加无参的构造方法
6.一个类中可以有多个构造方法
this关键字：

封装：
1、将类的某些信息隐藏在类内部，不允许外部程序直接访问
2、通过该类提供的方法来实现对隐藏信息的操作和访问
3、隐藏对象的信息
4、流出访问的接口
封装实现
1、修改属性的可见性，设为private
2、创建getter/setter方法，设为public用于属性的读写
3、在getter/setter方法中加入属性控制语句，对属性值的合法性进行判断

Java中一个包里面不能存在同名类

跨包调用的实现形式：
import +包名信息 使用 .*加载全部的信息
import +包名.类名，加载固定的类
在程序中直接加载包名.类名去加载
不能加载不同包中的同一个类名在最后一个成员
加载import的顺序与导入的顺序无关


static关键字：
public static int prices; 静态成员、类成员，共用一个存储空间，
1、类对象共享
2、类加载时产生，销毁时释放，生命周期长
静态成员访问方式：
1、对象.成员
2、类名.成员
static放在方法前面：叫做类方法、静态方法，推荐使用类名.静态成员进行调用
在类的前面，不能添加static，局部变量前面不允许添加static修饰符
静态方法中不能直接访问同一个类中的非静态成员，只能直接调用同一个类中的静态成员
只能通过对象实例化后，对象.成员方法的方式访问非静态成员
静态方法中不能使用this

普通代码块：顺序执行，先出现、先执行
构造代码块：创建对象时调用，优先于构造方法执行
静态代码块：类加载时调用，优先于构造代码块执行
无论产生多少的类实例，静态代码块只执行一次，仅希望执行一次的代码，可以放在静态代码块中

在方法中通过对象作为参数，传递的是它的引用，可以通过引用获取该对象所有信息

继承：
特点：一种类与类之间的关系，使用已存在的类的定义作为基础建立新类
新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性的继承父类，父类不能访问子类的成员和方法

方法重载：
1、同一个类中
2、方法名相同，参数列表不同（参数顺序、个数、类型）
3、方法返回值、访问修饰符任意
4、与方法的参数名无关

方法重写：
1、有继承关系的子类中
2、方法名相同，参数列表相同（参数顺序、个数、类型）必须相同
3、方法的访问修饰符是可以允许有变化的，但是是有条件的：访问范围需要大于等于父类的访问范围
4、与方法的参数名无关
5、父类的构造方法是不允许被继承的，也不能被重写

访问修饰符：
公有的：public，允许在任意位置进行访问
私有的：private,只允许在本类中进行访问
受保护的：protected，允许在当前类、同包子类、跨包子类中调用，跨包的非子类不允许调用，同包的时候，非子类也可以访问
默认的，不加任何权限：允许在当前类、同包子类/同包非子类，跨包子类、跨包非子类不允许访问

super关键字，代表父类对象的引用
父类的构造方法是不允许被继承的，也不能被重写，但是会影响子类的实例化
子类构造默认调用父类的无参构造方法，可以通过super()调用父类允许被访问的其他构造方法，---无参构造很重要
super()必须放在子类构造方法有效代码第一行
子类的构造的过程中必须调用其父类的构造方法
如果子类的构造方法中没有显示标注，则默认调用父类无参的构造方法
如果子类的构造方法中既没有显示标注，且父类中没有无参构造方法，则编译出错

super()-代表父类引用
    super.print();访问父类成员方法
    super.name;访问父类属性
    super;访问父类构造方法

object是所有类的父类

继承后的初始化顺序：
父类静态成员->子类静态成员->父类对象构造->子类对象构造
访问修饰符不影响成员加载顺序，跟书写位置有关

this:当前类对象的引用
    - 访问当前类的成员方法
    - 访问当前类的成员属性
    - 访问当前类的构造方法
    - 不能在静态方法中使用
super：父类对象的引用
    - 访问父类的成员方法
    - 访问父类的成员属性
    - 访问父类的构造方法
    - 不能在静态方法中使用
构造方法调用时，super和this不能同时使用
